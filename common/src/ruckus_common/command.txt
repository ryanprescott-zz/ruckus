I would like to update the ruckus agent job endpoints as follows: 1. The /execute endpoint (used to execute jobs) should take an instance of a new class: ExecuteJobRequest, defined in common/src/ruckus_common/models.py. This class has the following fields: A. experiment_spec: ExperimentSpec - the experiment specification to be executed by the agent. B. job_id: str - a unique identifier for the job being executed. 2. Change the /execute endpoint verb and path to POST /api/v1/jobs 3. Add a job status endpoint: GET /api/v1/status/{job_id} that returns the current JobStatus for the job with the provided job_id. The JobStatus class is defined in common/src/ruckus_common/models.py. Do you have any questions before we start implementing these changes?


I want to implement a new manager class to manage jobs in the ruckus server. The new class, JobManager, will be responsible for creating jobs, tracking their status, and interfacing with agents to run experiments. The JobManager will be similar in structure to the existing AgentManager and ExperimentManager classes. The JobManager is responsible for keeping track of jobs that are currently running, jobs that are queued because the Agent they were created for are busy running other jobs, and jobs that have completed for failed. The JobManager will use the configured StorageBackend to persist job This information. The FastAPI app will maintain an instance of the JobManager in app.state, and will manage the lifecycle of the JobManager following the pattern used for the AgentManager and ExperimentManager. The JobManager will be started when the FastAPI app starts, and will be stopped when the app shuts down. The JobManager will use the AgentUtility class to interact with Agents, following the pattern used in the AgentManager class. The JobManager will also use Pydantic models to define the data structures used for jobs, following the pattern used in the ExperimentManager class. The JobManager will be implemented in a new file: src/ruckus_server/core/job_manager.py. The JobManager uses a new class defined in server/src/ruckus_server/core/models.py called JobInfo to keep track of information about jobs. The JobInfo class has the following fields: 1. experiment_id: str - the ID of the experiment the job is assigned to. 2. agent_id: str - The id of the Agent the job is assigned to. 3. created_time: datetime - the timestamp when the job was created by the server. 4. status: JobStatus - the current status of the job. JobStatus is a new class  defined in common/src/ruckus_common/models.py. Note: there is an exsiting JobStatus class that is an enum; this class should be renamed JobStatusEnum. The new JobStatus class will have the following fields: 1. status: JobStatusEnum - the renamed enum class that is currently named JobStatus. 2. timestamp the timestamp when the JobStatus object was fetched from the agent (set by the agent). 3. message: str - A message providing context for the status enum. The JobManager maintains four separate persistent sets of JobInfo objects for each agent that the server is interacting with to run jobs: 1. The JobInfo object of the current running job (or None if there is no current running job), 2. A list of JobInfo objects for completed jobs (those with a status enum of COMPLETED), 3. A list of JobInfo objects for failed jobs - these include jobs with status of FAILED, CANCELLED, or TIMEOUT. 4. A list of JobInfo objects for queued jobs that haven't been run yet because the Agent is busy with other jobs. All of these JobInfo data are persisted for each Agent using the configured StorageBackend. To start with, let's define the JobManager methods used to create and update jobs. The create_job method 1. generates a new job ID using a new JobUtiliy class' generate_job_id() method, which generates a new ID combining the 'job_' prefix with a unique number no more than 8 digits long (e.g. using a UUID method). 2. calls the process_job method, passing in the job ID, experiment ID and agent ID. 3. Creates a JobInfo object using the job ID, experiment ID, agent ID and JobStatus object returned by the process_job method. 4. Processes the JobInfo object as follows: A. If the returned JobStatus object's status enum is ASSIGNED or RUNNING, store the JobInfo object as the currently running job for the Agent by calling a method on the configured StorageBackend. B. If the returned JobStatus object's status enum is QUEUED, update the stored list of queued jobs, appending this JobInfo to the end of the list by calling a method on the configured StorageBackend. C. If the returned JobStatus object's status enum is FAILED, CANCELLED or TIMEOUT, add the JobInfo to the list of failed jobs for the Agent by calling a method on the configured StorageBackend. D. If the returned JobStatus object's status enum is COMPLETE, add the JobInfo to the list of completed jobs for the Agent by calling a method on the configured StorageBackend. The process_job method takes three arguments: 1. job_id: str, 2. experiment_id: str, 3. agent_id: str. This method first retrieves the experiment with the provided experiment_id from the configured StorageBackend. If no experiment with the provided ID is found in the storage backend, the method raises an exception signaling that the experiment does not exist. The method next retrieves RegisteredAgentInfo from the storage backend for the agent matching the provided agent_id. If no agent is found matching the provided ID, the method raises an exception signaling that the agent does not exist. If the agent status from the retrieved RegisteredAgentInfo is UNAVAILABLE the method creates and returns a new JobStatus object with a status enum of FAILED and a message indicating that the agent is unavailable. Otherwise, the method calls the agent's /status endpoint by passing the agent URL from the registered agent info to a new method on the AgentUtility: get_agent_status(). If the call to get_agent_status() fails (i.e. it raises an exception or returns a non-200 status code), the method creates and returns a new JobStatus object with a status enum of FAILED, and a message indicating the call failure. If the returned AgentStatus object has a status enum of ERROR, the method creates and returns a new JobStatus object with a status enum of FAILED, and a message indicating the agent ERROR status. If the returned AgentStatus object has a status enum of ACTIVE, the method creates and returns a new JobStatus object with a status enum of QUEUED, and a message indicating that the agent is busy. If the returned AgentStatus object has a status enum of IDLE, the method calls the Agent's /execute endpoint by passing the ExperimentSpec retrieved from storage and the job ID to a new method on the AgentUtility: execute_experiment(), which calls the agent's /execute endpoint, passing the ExperimentSpec and job ID in the request body. If the call to execute_experiment() fails (e.g., due to a non-200 status code), the method creates and returns a new JobStatus object with a status enum of FAILED, and a message indicating the call failure. If the call to execute_experiment() is successful (i.e. it returns a 200 status code), the method: 1. schedules a job status polling method to be called every <job_status_polling_interval> seconds (where job_status_polling_interval is configured in a new JobManagerSettings pydantic settings class in server/src/ruckus_server/core/config.py). 2. creates and returns a new JobStatus object with a status enum of ASSIGNED, and a message indicating that the job has been scheduled with the agent. The status polling method: process_job_status() takes a single argument: job_id: str. This method 1. calls the Agent's /status endpoint by passing the agent URL from the RegisteredAgentInfo to a new method on the AgentUtility: get_agent_status(). 2. If the call to get_agent_status() fails (i.e. it raises an exception or returns a non-200 status code), or if the returned status' status enum has a value of FAILED, CANCELLED or TIMEOUT, Create a JobInfo object with the JobId and returned status, add the JobInfo to the list of failed jobs for the Agent by calling a method on the configured StorageBackend, cancel the polling for this job, and call the process_next_job(). 3. If the returned status' status enum has a value of COMPLETE, Create a JobInfo object with the JobId and returned status, add the JobInfo to the list of completed jobs, cancel the polling for this job, call the process_job_results() method, and then call the process_next_job() method. 4. If the returned status' status enum has a value of ASSIGNED or RUNNING, update the currently running job's JobInfo object with the new status and timestamp by calling a method on the configured StorageBackend. 5. If the returned status' status enum has a value of QUEUED, Create a JobInfo object with the JobId and returned status, add the JobInfo to the list of queued jobs for the Agent by calling a method on the configured StorageBackend, cancel the polling for this job, and call the process_next_job(). The process_next_job() method checks if there are any queued jobs for the Agent by fetching the list of queued job JobStatusObjects from storage using the configured StorageBackend. If there are no queued jobs, the method returns without doing anything further. If there are queued jobs, the method retrieves the first JobInfo object from the list of queued jobs, removes it from the list of queued jobs in storage, and calls the process_job() method, passing in the job ID, experiment ID and agent ID from the JobInfo object. Depending on the returned JobStatus object's status enum, the method processes the JobInfo object as follows: A. If the returned JobStatus object's status enum is ASSIGNED or RUNNING, store the JobInfo object as the currently running job for the Agent by calling a method on the configured StorageBackend. B. If the returned JobStatus object's status enum is QUEUED, update the stored list of queued jobs, appending this JobInfo to the end of the list by calling a method on the configured StorageBackend. C. If the returned JobStatus object's status enum is FAILED, CANCELLED or TIMEOUT, add the JobInfo to the list of failed jobs for the Agent by calling a method on the configured StorageBackend. D. If the returned JobStatus object's status enum is COMPLETE, add the JobInfo to the list of completed jobs for the Agent by calling a method on the configured StorageBackend. The process_job_results() method takes parameters: job_id: str and agnet_id: str. This method retrieves results from the Agent for completed jobs. The method first retrieves the RegisteredAgentInfo from storage for the agent matching the provided agent_id. If no agent is found matching the provided ID, the method raises an exception signaling that the agent does not exist. The method next retrieves the JobInfo object for the completed job matching the provided job_id from storage. If no job is found matching the provided ID, the method raises an exception signaling that the job does not exist. The method then calls a new method on the AgentUtility: get_experiment_results(), passing in the agent URL from the RegisteredAgentInfo and the job ID. If the call to get_experiment_results() fails (i.e. it raises an exception or returns a non-200 status code), the method logs an error message indicating that results could not be retrieved for the job, and returns without doing anything further. If the call to get_experiment_results() is successful (i.e. it returns a 200 status code), the method persists the returned results to storage using a new method on the configured StorageBackend: save_experiment_results(), passing in the experiment ID from the JobInfo object and the results data. Do you have any questions before we start implementing the JobManager class?