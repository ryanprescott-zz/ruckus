│ > I want to implement job-related functionality in the ruckus server, including router endpoints, backend functionality, model updates, etc.   │
│   To get started, I would like to add a new endpoint to the jobs router in src/ruckus_server/api/v1/routers/jobs.py: POST /api/v1/jobs/ to     │
│   create a new job. The endpoint takes an instance of CreateJobRequest - a new model class in src/ruckus_server/api/v1/models.py that          │
│   contains the following fields: A. experiment_id: str - the ID of the experiment to run in the job. B. agent_id: str - the ID of the Agent    │
│   that will run the job. When the endpoint is called, it calls the create_job method on a new class: JobManager (in                            │
│   src/ruckus_server/core/job_manager.py), passing the experiment_id and agent_id from the CreateJobRequest object. The create_job method does  │
│   the following 1. calls the configured StorageBackend (configured in the JobManager start() methdod, following the pattern of the             │
│   AgentManager and ExperimentManager by calling the storage_factory.create_storage_backend() method with the setting specifing the backend to  │
│   use) to retrieve the experiment with the provided experiment_id. If no experiment with the provided ID is found in the storage backend,      │
│   the method raises an exception signaling the endpoint to return a 404 message. Otherwise, the method next retrieves RegisteredAgentInfo      │
│   from the storage backend for the agent matching the provided agent_id. If no agent is found matching the provided ID, the method raises an   │
│   exception signaling the endpoint to return a 404 message. Otherwise, next the method calls the agent's /status endpoint by passing the       │
│   agent URL from the registered agent info to a new method on the AgentUtility: get_agent_status(). If the returned AgentStatus object has a   │
│   status enum of idle, the method calls the Agent's  2. Refactor the GET /api/v1/jobs/ endpoint (which provides information on the current     │
│   jobs known to the server) to return an instance of JobListResponse - a new model class (in server/src/ruckus_server/api/v1/models)           │
│   containing a list of JobStatus objects (one per job). The JobStatus class is a refactered version of the existing JobStatus enum class  in   │
│   server/src/ruckus_server/core/models.py) The refactored JobStatus class contains the following fields: A. status: JobStatusEnum - the        │
│   renamed enum class that is currently named JobStatus. B. experiment_id: str - the ID of the experiment the job is running. C. agent_id: str  │
│   - The id of the Agent the job is running in, D. start_time: datetime - the timestamp when the job was started by the agent. E. timestamp:    │
│   datetime - the time of the status. WHen the endpoint is called, it 


I want to implement a new manager class to manage jobs in the ruckus server. The new class, JobManager, will be responsible for creating jobs, tracking their status, and interfacing with agents to run experiments. The JobManager will be similar in structure to the existing AgentManager and ExperimentManager classes. The JobManager is responsible for keeping track of jobs that are currently running, jobs that are queued because the Agent they were created for are busy running other jobs, and jobs that have completed for failed. The JobManager will use the configured StorageBackend to persist job This information. The FastAPI app will maintain an instance of the JobManager in app.state, and will manage the lifecycle of the JobManager following the pattern used for the AgentManager and ExperimentManager. The JobManager will be started when the FastAPI app starts, and will be stopped when the app shuts down. The JobManager will use the AgentUtility class to interact with Agents, following the pattern used in the AgentManager class. The JobManager will also use Pydantic models to define the data structures used for jobs, following the pattern used in the ExperimentManager class. The JobManager will be implemented in a new file: src/ruckus_server/core/job_manager.py. First, let's define the JobManager method used to create jobs. The create_job method takes an experiment_id and an agent_id as parameters. The method first retrieves the experiment with the provided experiment_id from the configured StorageBackend. If no experiment with the provided ID is found in the storage backend, the method raises an exception signaling the endpoint to return a 404 message. Otherwise, the method next retrieves RegisteredAgentInfo from the storage backend for the agent matching the provided agent_id. If no agent is found matching the provided ID, the method raises an exception signaling the endpoint to return a 404 message. Otherwise, if the agent status from the retrieved RegisteredAgentInfo is UNAVAILABLE or ERROR, the next the method calls the agent's /status endpoint by passing the agent URL from the registered agent info to a new method on the AgentUtility: get_agent_status(). If the returned AgentStatus object has a status enum of idle, the method calls the Agent's /execute endpoint by passing the ExperimentSpec retrieved from storage to a new method on the AgentUtility: execute_experiment(). If the call to execute_experiment() is successful (i.e. it returns a 200 status code), the method creates a new JobStatus object with a status enum of running, and persists it to storage using the configured StorageBackend. If the call to run_experiment() fails (i.e. it returns a non-200 status code), the method creates a new JobStatus object with a status enum of failed, and persists it to storage using the configured StorageBackend. If the returned AgentStatus object has a status enum of busy, the method creates a new JobStatus object with a status enum of queued, and persists it to storage using the configured StorageBackend. The create_job method returns the created JobStatus object.